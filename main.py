{
  "cells": [
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {
        "id": "wImBMUtO66Hi"
      },
      "outputs": [],
      "source": [
        "import numpy as np\n",
        "import matplotlib.pyplot as plt\n",
        "import matplotlib.patches as patches\n",
        "from time import time\n",
        "\n",
        "\n",
        "class GridWorld:\n",
        "    def __init__(self, filename, reward, random_rate, time_limit=1000):\n",
        "        file = open(filename)\n",
        "        self.map = np.array(\n",
        "            [list(map(float, s.strip().split(\",\"))) for s in file.readlines()]\n",
        "        )\n",
        "        file.close()\n",
        "        self.num_rows = self.map.shape[0] #3\n",
        "        self.num_cols = self.map.shape[1] #4\n",
        "        self.num_states = self.num_rows * self.num_cols\n",
        "        self.num_actions = 4\n",
        "        self.reward = reward\n",
        "        self.random_rate = random_rate\n",
        "        self.time_limit = time_limit\n",
        "        self.reward_function = self.get_reward_function()\n",
        "        self.transition_model = self.get_transition_model()\n",
        "\n",
        "    def get_state_from_pos(self, pos):\n",
        "        return pos[0] * self.num_cols + pos[1]\n",
        "\n",
        "    def get_pos_from_state(self, state):\n",
        "        return state // self.num_cols, state % self.num_cols\n",
        "\n",
        "    def get_reward_function(self):\n",
        "        reward_table = np.zeros(self.num_states)\n",
        "        for r in range(self.num_rows):\n",
        "            for c in range(self.num_cols):\n",
        "                s = self.get_state_from_pos((r, c))\n",
        "                reward_table[s] = self.reward[self.map[r, c]]\n",
        "        return reward_table\n",
        "\n",
        "    def get_transition_model(self):\n",
        "      transition_model = np.zeros((self.num_states, self.num_actions, self.num_states)) #Initialize transition_model\n",
        "\n",
        "      for r in range(self.num_rows):\n",
        "        for c in range(self.num_cols):\n",
        "            s = self.get_state_from_pos((r, c))\n",
        "\n",
        "\n",
        "            if self.map[r, c] == 3:  # Non-traversable (walls/obstacles)\n",
        "              for a in range(self.num_actions):\n",
        "                    transition_model[s, a, s] = 1.0  # Stay in place\n",
        "              continue\n",
        "\n",
        "\n",
        "            movements = {\n",
        "                0: (-1, 0),  # Up\n",
        "                1: (0, 1),   # Right\n",
        "                2: (1, 0),   # Down\n",
        "                3: (0, -1)   # Left\n",
        "            }\n",
        "\n",
        "            for a, (dr, dc) in movements.items():\n",
        "                new_r, new_c = r + dr, c + dc\n",
        "\n",
        "                # Check if the new position is within bounds and not an obstacle\n",
        "                if 0 <= new_r < self.num_rows and 0 <= new_c < self.num_cols and self.map[new_r, new_c] != 3:\n",
        "                    s_prime = self.get_state_from_pos((new_r, new_c))\n",
        "                else:\n",
        "                    s_prime = s  # If movement is blocked, stay in place\n",
        "\n",
        "                # Assign transition probabilities\n",
        "                transition_model[s, a, s_prime] = 1 - self.random_rate  # Intended movement\n",
        "\n",
        "                # Random drift (left and right)\n",
        "                left_a = (a - 1) % 4\n",
        "                right_a = (a + 1) % 4\n",
        "\n",
        "                # Left drift\n",
        "                dr, dc = movements[left_a]\n",
        "                left_r, left_c = r + dr, c + dc\n",
        "                left_s = (\n",
        "                    self.get_state_from_pos((left_r, left_c))\n",
        "                    if 0 <= left_r < self.num_rows and 0 <= left_c < self.num_cols and self.map[left_r, left_c] != 3\n",
        "                    else s\n",
        "                )\n",
        "                transition_model[s, a, left_s] += self.random_rate / 2\n",
        "\n",
        "                # Right drift\n",
        "                dr, dc = movements[right_a]\n",
        "                right_r, right_c = r + dr, c + dc\n",
        "                right_s = (\n",
        "                    self.get_state_from_pos((right_r, right_c))\n",
        "                    if 0 <= right_r < self.num_rows and 0 <= right_c < self.num_cols and self.map[right_r, right_c] != 3\n",
        "                    else s\n",
        "                )\n",
        "                transition_model[s, a, right_s] += self.random_rate / 2\n",
        "\n",
        "      return transition_model\n",
        "\n",
        "\n",
        "    def generate_random_policy(self):\n",
        "        return np.random.randint(self.num_actions, size=self.num_states)\n",
        "\n",
        "    def execute_policy(self, policy, start_pos):\n",
        "      s = self.get_state_from_pos(start_pos)\n",
        "      total_reward = self.reward_function[s]\n",
        "\n",
        "      start_time = int(round(time() * 1000))\n",
        "\n",
        "      while self.reward_function[s] not in [self.reward[1], self.reward[2]]:  # Not a terminal state\n",
        "          next_s_probs = self.transition_model[s, policy[s]]\n",
        "          s = np.random.choice(self.num_states, p=next_s_probs)  # Choose next state\n",
        "          total_reward += self.reward_function[s]\n",
        "\n",
        "          # Check if time limit is exceeded\n",
        "          cur_time = int(round(time() * 1000)) - start_time\n",
        "          if cur_time > self.time_limit:\n",
        "              return float('-inf')  # Timeout failure\n",
        "\n",
        "      return total_reward  # Successfully reached terminal state\n",
        "\n",
        "\n",
        "    def random_start_policy(self, policy, start_pos, n=100, plot=True):\n",
        "        start_time = int(round(time() * 1000))\n",
        "        overtime = False\n",
        "        scores = np.zeros(n)\n",
        "        i = 0\n",
        "        while i < n:\n",
        "            temp = self.execute_policy(policy=policy, start_pos=start_pos)\n",
        "            print(f'i = {i} Random start result: {temp}')\n",
        "            if temp > float('-inf'):\n",
        "                scores[i] = temp\n",
        "                i += 1\n",
        "            cur_time = int(round(time() * 1000)) - start_time\n",
        "            if cur_time > n * self.time_limit:\n",
        "                overtime = True\n",
        "                break\n",
        "\n",
        "        print(f'max = {np.max(scores)}')\n",
        "        print(f'min = {np.min(scores)}')\n",
        "        print(f'mean = {np.mean(scores)}')\n",
        "        print(f'std = {np.std(scores)}')\n",
        "\n",
        "        if overtime is False and plot is True:\n",
        "            bins = 100\n",
        "            fig, ax = plt.subplots(1, 1, figsize=(6, 4), dpi=300)\n",
        "            ax.set_xlabel('Total rewards in a single game')\n",
        "            ax.set_ylabel('Frequency')\n",
        "            ax.hist(scores, bins=bins, color='#1f77b4', edgecolor='black')\n",
        "            plt.show()\n",
        "\n",
        "        if overtime is True:\n",
        "            print('Overtime!')\n",
        "            return None\n",
        "        else:\n",
        "            return np.max(scores), np.min(scores), np.mean(scores)\n",
        "\n",
        "    def blackbox_move(self, s, a):\n",
        "        temp = self.transition_model[s, a]\n",
        "        s_prime = np.random.choice(self.num_states, p=temp)\n",
        "        r = self.reward_function[s_prime]\n",
        "        return s_prime, r\n",
        "\n",
        "    def plot_map(self, fig_size=(8, 6)):\n",
        "        unit = min(fig_size[1] // self.num_rows, fig_size[0] // self.num_cols)\n",
        "        unit = max(1, unit)\n",
        "        fig, ax = plt.subplots(1, 1, figsize=fig_size)\n",
        "        ax.axis('off')\n",
        "        for i in range(self.num_cols + 1):\n",
        "            if i == 0 or i == self.num_cols:\n",
        "                ax.plot([i * unit, i * unit], [0, self.num_rows * unit],\n",
        "                        color='black')\n",
        "            else:\n",
        "                ax.plot([i * unit, i * unit], [0, self.num_rows * unit],\n",
        "                        alpha=0.7, color='grey', linestyle='dashed')\n",
        "        for i in range(self.num_rows + 1):\n",
        "            if i == 0 or i == self.num_rows:\n",
        "                ax.plot([0, self.num_cols * unit], [i * unit, i * unit],\n",
        "                        color='black')\n",
        "            else:\n",
        "                ax.plot([0, self.num_cols * unit], [i * unit, i * unit],\n",
        "                        alpha=0.7, color='grey', linestyle='dashed')\n",
        "\n",
        "        for i in range(self.num_rows):\n",
        "            for j in range(self.num_cols):\n",
        "                y = (self.num_rows - 1 - i) * unit\n",
        "                x = j * unit\n",
        "                if self.map[i, j] == 3:\n",
        "                    rect = patches.Rectangle((x, y), unit, unit, edgecolor='none', facecolor='black',\n",
        "                                             alpha=0.6)\n",
        "                    ax.add_patch(rect)\n",
        "                elif self.map[i, j] == 2:\n",
        "                    rect = patches.Rectangle((x, y), unit, unit, edgecolor='none', facecolor='red',\n",
        "                                             alpha=0.6)\n",
        "                    ax.add_patch(rect)\n",
        "                elif self.map[i, j] == 1:\n",
        "                    rect = patches.Rectangle((x, y), unit, unit, edgecolor='none', facecolor='green',\n",
        "                                             alpha=0.6)\n",
        "                    ax.add_patch(rect)\n",
        "\n",
        "        plt.tight_layout()\n",
        "        plt.show()\n",
        "\n",
        "    def plot_policy(self, policy, fig_size=(8, 6)):\n",
        "        unit = min(fig_size[1] // self.num_rows, fig_size[0] // self.num_cols)\n",
        "        unit = max(1, unit)\n",
        "        fig, ax = plt.subplots(1, 1, figsize=fig_size)\n",
        "        ax.axis('off')\n",
        "        for i in range(self.num_cols + 1):\n",
        "            if i == 0 or i == self.num_cols:\n",
        "                ax.plot([i * unit, i * unit], [0, self.num_rows * unit],\n",
        "                        color='black')\n",
        "            else:\n",
        "                ax.plot([i * unit, i * unit], [0, self.num_rows * unit],\n",
        "                        alpha=0.7, color='grey', linestyle='dashed')\n",
        "        for i in range(self.num_rows + 1):\n",
        "            if i == 0 or i == self.num_rows:\n",
        "                ax.plot([0, self.num_cols * unit], [i * unit, i * unit],\n",
        "                        color='black')\n",
        "            else:\n",
        "                ax.plot([0, self.num_cols * unit], [i * unit, i * unit],\n",
        "                        alpha=0.7, color='grey', linestyle='dashed')\n",
        "\n",
        "        for i in range(self.num_rows):\n",
        "            for j in range(self.num_cols):\n",
        "                y = (self.num_rows - 1 - i) * unit\n",
        "                x = j * unit\n",
        "                if self.map[i, j] == 3:\n",
        "                    rect = patches.Rectangle((x, y), unit, unit, edgecolor='none', facecolor='black',\n",
        "                                             alpha=0.6)\n",
        "                    ax.add_patch(rect)\n",
        "                elif self.map[i, j] == 2:\n",
        "                    rect = patches.Rectangle((x, y), unit, unit, edgecolor='none', facecolor='red',\n",
        "                                             alpha=0.6)\n",
        "                    ax.add_patch(rect)\n",
        "                elif self.map[i, j] == 1:\n",
        "                    rect = patches.Rectangle((x, y), unit, unit, edgecolor='none', facecolor='green',\n",
        "                                             alpha=0.6)\n",
        "                    ax.add_patch(rect)\n",
        "                s = self.get_state_from_pos((i, j))\n",
        "                if self.map[i, j] == 0:\n",
        "                    a = policy[s]\n",
        "                    symbol = ['^', '>', 'v', '<']\n",
        "                    ax.plot([x + 0.5 * unit], [y + 0.5 * unit], marker=symbol[a],\n",
        "                            linestyle='none', markersize=max(fig_size)*unit, color='#1f77b4')\n",
        "\n",
        "        plt.tight_layout()\n",
        "        plt.show()\n",
        "\n",
        "    def visualize_value_policy(self, policy, values, fig_size=(8, 6)):\n",
        "        unit = min(fig_size[1] // self.num_rows, fig_size[0] // self.num_cols)\n",
        "        unit = max(1, unit)\n",
        "        fig, ax = plt.subplots(1, 1, figsize=fig_size)\n",
        "        ax.axis('off')\n",
        "\n",
        "        for i in range(self.num_cols + 1):\n",
        "            if i == 0 or i == self.num_cols:\n",
        "                ax.plot([i * unit, i * unit], [0, self.num_rows * unit],\n",
        "                        color='black')\n",
        "            else:\n",
        "                ax.plot([i * unit, i * unit], [0, self.num_rows * unit],\n",
        "                        alpha=0.7, color='grey', linestyle='dashed')\n",
        "        for i in range(self.num_rows + 1):\n",
        "            if i == 0 or i == self.num_rows:\n",
        "                ax.plot([0, self.num_cols * unit], [i * unit, i * unit],\n",
        "                        color='black')\n",
        "            else:\n",
        "                ax.plot([0, self.num_cols * unit], [i * unit, i * unit],\n",
        "                        alpha=0.7, color='grey', linestyle='dashed')\n",
        "\n",
        "        for i in range(self.num_rows):\n",
        "            for j in range(self.num_cols):\n",
        "                y = (self.num_rows - 1 - i) * unit\n",
        "                x = j * unit\n",
        "                s = self.get_state_from_pos((i, j))\n",
        "                if self.map[i, j] == 3:\n",
        "                    rect = patches.Rectangle((x, y), unit, unit, edgecolor='none', facecolor='black',\n",
        "                                             alpha=0.6)\n",
        "                    ax.add_patch(rect)\n",
        "                elif self.map[i, j] == 2:\n",
        "                    rect = patches.Rectangle((x, y), unit, unit, edgecolor='none', facecolor='red',\n",
        "                                             alpha=0.6)\n",
        "                    ax.add_patch(rect)\n",
        "                elif self.map[i, j] == 1:\n",
        "                    rect = patches.Rectangle((x, y), unit, unit, edgecolor='none', facecolor='green',\n",
        "                                             alpha=0.6)\n",
        "                    ax.add_patch(rect)\n",
        "                if self.map[i, j] != 3:\n",
        "                    ax.text(x + 0.5 * unit, y + 0.5 * unit, f'{values[s]:.4f}',\n",
        "                            horizontalalignment='center', verticalalignment='center',\n",
        "                            fontsize=max(fig_size)*unit*0.6)\n",
        "                if policy is not None:\n",
        "                    if self.map[i, j] == 0:\n",
        "                        a = policy[s]\n",
        "                        symbol = ['^', '>', 'v', '<']\n",
        "                        ax.plot([x + 0.5 * unit], [y + 0.5 * unit], marker=symbol[a], alpha=0.4,\n",
        "                                linestyle='none', markersize=max(fig_size)*unit, color='#1f77b4')\n",
        "\n",
        "        plt.tight_layout()\n",
        "        plt.show()"
      ]
    },
    
